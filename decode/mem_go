package decode

import (
	"errors"
	"strings"

	"github.com/ionous/tell/notes"
	"github.com/ionous/tell/token"
)

func makeMemo(n notes.Commentator) memo {
	m := memo{Commentator: n}
	m.noteAt = m.memoDocHeader()
	return m
}

type memo struct {
	notes.Commentator
	noteAt memoState
}

type memoState func(el, hash token.Pos, str string) error

func (m *memo) popped(cnt int) {
	if cnt > 0 {
		for i := 0; i < cnt; i++ {
			m.Commentator.OnCollectionEnded()
		}
		m.noteAt = m.memoValue()
	}
}

func (m *memo) newComments() (ret *strings.Builder) {
	keepComments := !notes.IsNothing(m.Commentator)
	if keepComments {
		ret = new(strings.Builder)
	}
	m.BeginCollection(ret)
	m.noteAt = m.memoKey()
	return
}

// custom message for custom case
func (m *memo) OnDocScalar() {
	m.Commentator.OnScalarValue()
	m.noteAt = m.memoDocScalar()
}

func (m *memo) OnScalarValue() notes.Commentator {
	m.Commentator.OnScalarValue()
	m.noteAt = m.memoValue()
	return m
}

func (m *memo) OnKeyDecoded() notes.Commentator {
	m.Commentator.OnKeyDecoded()
	m.noteAt = m.memoKey()
	return m
}

// allow any nesting; normalizes to non-nested
// check for blank lines, and issue blank comments
//
// # ....
// <value>
//
func (m *memo) memoDocHeader() memoState {
	return func(el, hash token.Pos, str string) (err error) {
		m.writeN(str)
		return
	}
}

// first line, no indent; everything else nested.
//
// "value" # <--- here
//   # <-- or here
//
func (m *memo) memoDocScalar() memoState {
	return m.checkInline(func(el, hash token.Pos, str string) (err error) {
		m.writeComment(str)
		memoScalar
		if len(str) > 0 { // the line was valid; so stick to its alignment
			indent, deindent := hash.X, el.X
			m.noteAt = m.alignedComments(indent, deindent, m.memoDocHeader())
		}
		return
	})

}

// same line -> inline comment, all must be aligned
// different line -> trailing, all must be aligned.
//
// -   "value" # <--- here
//      # <-- or here
//
func (m *memo) memoValue() memoState {
	return m.checkInline(func(el, hash token.Pos, str string) (err error) {
		m.writeComment(str)
		if len(str) > 0 { // the line was valid; so stick to its alignment
			indent, deindent := hash.X, el.X
			m.noteAt = m.alignedComments(indent, deindent, m.interKey())
		}
		return
	})
}

// check for blank lines, and issue blank comments
// check for nesting based on key start
// ( one space is probably an error )
//
// Key: # < -- here is trailing inline
//   # <-- here is trailing block
// # .... < -- here triggers a nil value
//
func (m *memo) memoKey() memoState {
	return m.checkInline(func(el, hash token.Pos, str string) (err error) {
		m.writeComment(str)
		// stop blank lines and inline comments from changing states
		if inline := hash.Y == el.Y; !inline && len(str) > 0 {
			// stop single line indentation
			if deindent := el.X + 2; hash.X < deindent {
				err = errors.New("key comments should be indented two spaces")
			} else if hash.X != deindent {
				// otherwise, we have to figure out what to do.
				// THERE'S a thing here about that the *second* line can be nested
				// and then stick to that nesting
				// or -- if we're at the deindent -- then we're a header
				// so stick here.
				if hash.X != deindent {
					// if hash.Y > el.Y
					indent := hash.X
					m.noteAt = m.alignedComments(indent, deindent, m.memoKey())
				}
			}
		}
		return
	})
}

// after value with same nesting as collection
// subsequent lines with greater nesting are nested
// ( except on blank lines, will never get shallower nestings )
//
// -
// # ....
//
func (m *memo) interKey() memoState {
	const (
		firstLine  = -2
		secondLine = -1
	)
	nesting := secondLine // assumes we've written the first line already
	return func(el, hash token.Pos, str string) (err error) {
		// newline or left-alignment; its a new first line:
		if empty := len(str) == 0; empty || hash.X == el.X {
			m.writeComment(str)
			if empty {
				nesting = firstLine
			} else {
				nesting = secondLine
			}
		} else if nesting == firstLine {
			err = errors.New("invalid indent")
		} else if nesting != secondLine && hash.X != nesting {
			err = errors.New("invalid nesting")
		} else {
			m.Commentator.OnNestedComment()
			m.writeComment(str)
			nesting = hash.X
		}
		return
	}
}

// check if the next comment is on the same line as the element
// if not, write a blank line. either way, send the comment to indicated next state.
func (m *memo) checkInline(next memoState) memoState {
	return func(el, hash token.Pos, str string) (err error) {
		if hash.Y > el.Y {
			m.writeComment("")
		}
		m.noteAt = next
		return next(el, hash, str)
	}
}

// all aligned lines are considered nested.
// we're returned to the element level on de-indent or a blank line.
// other indentations are errors.
// tbd: if this is good enough for the document footer.
func (m *memo) alignedComments(indent, deindent int, onElement memoState) memoState {
	return func(el, hash token.Pos, str string) (err error) {
		if hash.X == deindent || len(str) == 0 {
			m.writeComment(str)
			m.noteAt = onElement
		} else if hash.X != indent {
			err = errors.New("misaligned comments")
		} else {
			m.Commentator.OnNestedComment()
			m.writeComment(str)
		}
		return
	}
}


// fix: just pass the whole thing at once
func (m *memo) writeComment(str string) {
	for _, q := range str {
		m.Commentator.WriteRune(q)
	}
}
