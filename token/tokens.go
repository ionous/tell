package token

import (
	"errors"
	"strings"
	"unicode"

	"github.com/ionous/tell/charm"
	"github.com/ionous/tell/charmed"
	"github.com/ionous/tell/runes"
)

//go:generate stringer -type=Type
type Type int

const (
	Invalid Type = iota // placeholder, not generated by the tokenizer
	Bool
	Number
	InterpretedString
	RawString
	Comment // a completely empty comment is a blank line
	Key     // an empty key means a sequence; otherwise a mapping

	// heredoc?
	// array?
)

func (t Type) Scalar() (ret bool) {
	switch t {
	case Bool, Number, InterpretedString, RawString:
		ret = true
	}
	return
}

type Notifier interface {
	Decoded(Pos, Type, any) error
}

type Pos struct {
	X, Y int
}

func NewTokenizer(notify Notifier) charm.State {
	t := tokenizer{notifier: notify}
	return charm.Parallel("tokenizer", t.decode(), charmed.DecodePos(&t.curr.Y, &t.curr.X))
}

type tokenizer struct {
	notifier    Notifier
	spaces      int  // token separated whitespace
	afterIndent bool // specifically, are we *after* the indent
	curr, start Pos
}

func (n *tokenizer) decode() charm.State {
	return charm.Step(n.whitespace(), n.tokenize())
}

func (n *tokenizer) notifyRune(q rune, t Type, v any) (ret charm.State) {
	if e := n.notifier.Decoded(n.start, t, v); e != nil {
		ret = charm.Error(e)
	} else {
		ret = send(n.decode(), q)
	}
	return
}

func (n *tokenizer) whitespace() charm.State {
	return charm.Self("ledespace", func(self charm.State, q rune) (ret charm.State) {
		switch q {
		case runes.Space:
			n.spaces++
			ret = self
		case runes.Newline:
			if !n.afterIndent { // blank line
				leftEdge := Pos{Y: n.curr.Y}
				n.notifier.Decoded(leftEdge, Comment, "")
			}
			n.spaces = 0
			n.afterIndent = false
			ret = self
		case runes.Eof:
			ret = charm.Error(nil)
		}
		return
	})
}

func (n *tokenizer) tokenize() charm.State {
	return charm.Statement("tokenize", func(q rune) (ret charm.State) {
		if n.afterIndent && n.spaces == 0 {
			e := errors.New("expected whitespace between tokens")
			ret = charm.Error(e)
		} else {
			n.spaces = 0
			n.afterIndent = true
			n.start = n.curr
			//
			switch {
			case q == runes.Hash:
				next := n.commentDecoder()
				ret = send(next, q)

			case q == runes.InterpretQuote:
				ret = n.interpretDecoding()

			case q == runes.RawQuote:
				ret = n.rawDecoding()

			case q == runes.Dash: // negative numbers or sequences
				ret = n.dashDecoding()

			case runes.IsNumber(q) || q == '+':
				next := n.numDecoder()
				ret = send(next, q)

			case unicode.IsLetter(q): // maps and bools
				next := n.wordDecoder()
				ret = send(next, q)
			}
		}
		return
	})
}

// if the passed rune might be start a bool value
// for example, `trouble:` would match `true` temporarily
// and `false:` would match `false` until the colon.
func (n *tokenizer) wordDecoder() charm.State {
	return charm.Statement("wordDecoder", func(q rune) (ret charm.State) {
		var b boolValue
		if q == 't' {
			b = boolTrue
		} else if q == 'f' {
			b = boolFalse
		}
		if b == boolInvalid {
			ret = n.decodeSignature()
		} else {
			var sig Signature
			sign := sig.Decoder()
			boolean := charmed.StringMatch(b.String())
			ret = charm.Self("parallel", func(self charm.State, q rune) (ret charm.State) {
				ret = self
				// sign succeeds and turns nil on whitespace after a colon;
				// boolean on the rune after its last letter.
				if sign = sign.NewRune(q); sign == nil {
					ret = n.notifyRune(q, Key, sig.String())
				} else if boolean = boolean.NewRune(q); boolean == nil {
					// boolean shouldnt match: ex. "falsey"
					if !runes.IsWhitespace(q) {
						boolean = charm.Error(nil)
					} else {
						// note: this means a key "true true:" will be interpreted as
						// a bool (true) followed by a key (true:)
						ret = n.notifyRune(q, Bool, b == boolTrue)
					}
				} else if terminal(sign) {
					// sign is mostly superset of bool; (except for the eof/eol cases)
					// if it dies and boolean didnt just succeed; they're both dead.
					ret = charm.Error(wordyError)
				}
				return
			})
		}
		return send(ret, q)
	})
}

// negative numbers or sequences
func (n *tokenizer) decodeSignature() charm.State {
	var sig Signature
	sign := sig.Decoder() // use self, instead of step to customize the error response
	return charm.Self("signature", func(self charm.State, q rune) (ret charm.State) {
		ret = self // provisionally
		if sign = sign.NewRune(q); sign == nil {
			ret = n.notifyRune(q, Key, sig.String())
		} else if terminal(sign) {
			ret = charm.Error(wordyError)
		}
		return
	})
}

// negative numbers or sequences
func (n *tokenizer) dashDecoding() charm.State {
	return charm.Statement("dashing", func(q rune) (ret charm.State) {
		if runes.IsWhitespace(q) { // a space indicates a sequence `- 5`
			ret = n.notifyRune(q, Key, "") // a blank key means a dash
		} else { // no space indicates a number ( or an error ) `-5`
			next := n.numDecoder()
			ret = send(next, runes.Dash, q)
		}
		return
	})
}

func (n *tokenizer) commentDecoder() charm.State {
	var b strings.Builder
	return charm.Self("comments", func(self charm.State, q rune) (ret charm.State) {
		switch q {
		default:
			b.WriteRune(q)
			ret = self
		case runes.Newline, runes.Eof:
			// tbd: using indenting could send "trailing" vs. "full line comment"
			ret = n.notifyRune(q, Comment, b.String())
		}
		return
	})
}

func (n *tokenizer) interpretDecoding() charm.State {
	var d charmed.QuoteDecoder
	return charm.Step(d.Interpret(), charm.Statement("interpreted", func(q rune) charm.State {
		return n.notifyRune(q, InterpretedString, d.String())
	}))
}

func (n *tokenizer) rawDecoding() charm.State {
	var d charmed.QuoteDecoder
	return charm.Step(d.Record(), charm.Statement("recorded", func(q rune) charm.State {
		return n.notifyRune(q, RawString, d.String())
	}))
}

// fix? returns float64 because json does
// could also return int64 when its int like
func (n *tokenizer) numDecoder() charm.State {
	var d charmed.NumParser
	return charm.Step(d.Decode(), charm.Statement("numDecoder", func(q rune) (ret charm.State) {
		if v, e := d.GetNumber(); e != nil {
			ret = charm.Error(e)
		} else {
			ret = n.notifyRune(q, Number, v)
		}
		return
	}))
}

// a tri-boolean: 0 is invalid, not false.
type boolValue int

//go:generate stringer -type=boolValue -linecomment
const (
	boolInvalid boolValue = iota
	boolFalse             // false
	boolTrue              // true
)

var wordyError = errors.New("couldn't read words. strings should be quoted, booleans should be 'true' or 'false', and map keys should start with a letter and end with a colon.")

func terminal(next charm.State) (okay bool) {
	_, okay = next.(charm.Terminal)
	return
}

func send(next charm.State, qs ...rune) charm.State {
	for _, q := range qs {
		if next = next.NewRune(q); next == nil {
			break
		}
	}
	return next
}
